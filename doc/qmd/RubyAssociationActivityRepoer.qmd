---
title: Ruby Association Activity Report
jupyter: ruby
---

# RedAmber - A simple dataframe library for Ruby

## 鈴木弘一 (@heronshoes)


## 今日のお話

- RedAmber というデータフレームライブラリを作っています
  - Apache Arrow の列指向のデータを扱えるライブラリ
  - Ruby らしい書き方でデータフレームの操作ができることを目指しています
    - 以前はライブラリの紹介文は「A simple dataframe library for Ruby」でしたが、最近「A dataframe library for Rubyists」に変えました
- Grant では主要な機能の実装を完成し、高速化、ドキュメント整備を頑張りました
  - 成果は[最終報告書](https://gist.github.com/heronshoes/d301bfd58adfbf51e28584bf2e68c190) にまとめてあります
  - RubyKaigi と その follow-up eventでもRedAmberの紹介をさせて頂きました（ありがとうございます）
- **今日は Grant 以前と以降の結果も交えてデモを行いながら、RubyらしいデータフレームとしてのRedAmber を作る際に考えていたことをお話しします**

## self.introduction

- 鈴木弘一 (Hirokazu SUZUKI)
- GitHub/ex-Twitter: @heronshoes
- 広島県福山市に住んでいます
- Ruby愛好家を自称するRubyist
- Red Data Tools / Rubyでデータ処理
- コーヒーとクラフトビールとMINIが好き 今は短歌がマイブームです

## RedAmber を動かす

```{ruby}
require 'red_amber'
require 'datasets-arrow'  # red-datasets（有名なデータセットを集めたライブラリ）、を arrowと連携できるようにしたもの

{ RedAmber: RedAmber::VERSION, Arrow: Arrow::VERSION, Datasets: Datasets::VERSION, Ruby: RUBY_VERSION }
```

## データフレームとは何か

![dataframe model of RedAmber](https://raw.githubusercontent.com/red-data-tools/red_amber/main/doc/image/dataframe_model.png)

```python
df = pd.DataFrame(np.arange(12).reshape(3, 4),
                  columns=['col_0', 'col_1', 'col_2', 'col_3'],
                  index=['row_0', 'row_1', 'row_2'])
print(df)
#        col_0  col_1  col_2  col_3
# row_0      0      1      2      3
# row_1      4      5      6      7
# row_2      8      9     10     11
```

RedAmberでは、行インデックスは特別扱いしないで、一つの列として扱う

```{ruby}
require 'arrow-numo-narray'
n_rows, n_cols = 3, 4
RedAmber::DataFrame.new(index: (0...n_rows).map { "row_#{_1}" })
  .assign do
    narray = Numo::Int8.new(n_rows, n_cols).seq
    (0...n_cols).map { |i| ["col_#{i}", narray[true, i]] }
  end
```

## Penguins データを読み込んでみる

元データは、Rの　palmerpenguins データセット,
Red Datasetsから取得できる.

```{ruby}
penguins = RedAmber::DataFrame.new(Datasets::Penguins.new)
```


データフレームの要約を行と列を転置して表示させる `#tdr` メソッド
- type : データの型 (Arrow Array の型)
- level : ユニークな要素の数 (カテゴリー数)
- データは tallyした形式または部分 Array で表示、nil と NaN の数も表示する

```{ruby}
penguins.tdr
```

Rでは,
```
str(penguins)

#> tibble [344 × 8] (S3: tbl_df/tbl/data.frame)
#>  $ species          : Factor w/ 3 levels "Adelie","Chinstrap",..: 1 1 1 1 1 1 1 1 1 1 ...
#>  $ island           : Factor w/ 3 levels "Biscoe","Dream",..: 3 3 3 3 3 3 3 3 3 3 ...
#>  $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...
#>  $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...
#>  $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...
#>  $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...
#>  $ sex              : Factor w/ 2 levels "female","male": 2 1 1 NA 1 2 1 2 NA NA ...
#>  $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...
```

`#tdr` は、transposed dataframe representation の頭文字

※ (RedAmberで工夫したことその1) **データフレームの内容をコンパクトに理解するための `#tdr` メソッドを作った**

数値的な要約＝統計量を表示する
- count : Varid な要素の数 (nil, NaNを除く）
- pandas とは違って、転置して表示している

```{ruby}
penguins.summary
```

```{ruby}
penguins.summary.transpose
```

```{ruby}
penguins.summary.keys
```

```{ruby}
penguins.summary.types
```

## Diamonds データセットを読み込んで例を示す

元データは、Rの　「Prices of over 50,000 round cut diamonds」,
Red Datasetsから利用できる.

```{ruby}
diamonds = RedAmber::DataFrame.new(Datasets::Diamonds.new)
```

```{ruby}
diamonds.tdr
```

```{ruby}
diamonds.carat
```

```{ruby}
diamonds.carat.mean
```

```{ruby}
diamonds.carat.quantiles
```

```{ruby}
diamonds.carat > 1
```

```{ruby}
diamonds.slice(diamonds.carat > 1)
# diamonds.slice { diamonds.carat > 1 }
# filter
```

```{ruby}
diamonds
  .slice { carat > 1 }
  .pick(:cut, :price)
  # .pick { vectors.map { _1.numeric? } }
  # .pick { keys.select { _1.to_s.start_with?('c') } }
```

```{ruby}
diamonds
  .slice { carat > 1 }
  .pick(:cut, :price)
  .group(:cut)
```

```{ruby}
diamonds
  .slice { carat > 1 }
  .pick(:cut, :price)
  .group(:cut)
  .mean
```

```{ruby}
diamonds
  .slice { carat > 1 }
  .pick(:cut, :price)
  .group(:cut)
  .mean
  .sort('-mean(price)')
```

```{ruby}
diamonds
  .slice { carat > 1 }
  .pick(:cut, :price)
  .group(:cut)
  .mean
  .sort('-mean(price)')
  .rename('mean(price)': :mean_price_usd)
```

```{ruby}
usdjpy = 110.0  # when the yen was stronger

diamonds
  .slice { carat > 1 }
  .pick(:cut, :price)
  .group(:cut)
  .mean
  .sort('-mean(price)')
  .rename('mean(price)': :mean_price_usd)
  # 新しい列を作る assign { [列のラベル, 列の値ベクトル] }
  .assign { [:mean_price_jpy, mean_price_usd * usdjpy] }

  # 新しい列を作る assign(列のラベル) { 列の値ベクトル }
  # .assign(:mean_price_jpy) { mean_price_usd * usdjpy } 
```

## データフレームの基本操作

- 列を選択する: `#pick`, 列を取り除く: `#drop`
- 行を選択する: `#slice`, 行を取り除く: `#remove`
  - `[行 ： 列]`でアドレッシングするやり方は、列指向でベクトル演算を主体とする場合は使われにくい
  - その代わり、選択指定子はインデックスの配列でも、ブーリアン配列でもどちらでも受け付けるようにした

![RedAmberの基本的なメソッド群](https://raw.githubusercontent.com/heronshoes/red_amber/main/doc/image/basic_verbs.png)

```{ruby}
#| collapsed: true
#| jupyter: {outputs_hidden: true}
#| scrolled: true
diamonds.slice { carat > 1 }
# puts diamonds.inspect
# diamonds.slice { [0..10, -10..-1] }
```

### DataFrames 操作メソッドの比較

RedAmberの基本的な操作メソッドを [Python pandas](https://pandas.pydata.org/),
[R Tidyverse](https://www.tidyverse.org/),
[Julia DataFrames](https://dataframes.juliadata.org/stable/) と比較

#### 列 (variables) を選択する

| 機能                               | RedAmber        | Tidyverse (R)	                  | pandas                                 | DataFrames.jl     |
|---                                 |---              |---                              |---                                     |---                |
| 列を選択して dataframe で返す       | **pick**, drop, []  | dplyr::select, dplyr::select_if | [], loc[], iloc[], drop, select_dtypes | [], select        |
| 列を選択して vector で返す          | [], v	         | dplyr::pull, [, x]	           | [], loc[], iloc[]                      | [!, :x]           |
| 列の順番を入れ替えた dataframeを返す | **pick**, [] 	     | relocate                        | [], reindex, loc[], iloc[]             | select,transform  |

列の中身をベクトルとして取り出す

```{ruby}
diamonds.carat
# diamonds[:carat]
# diamonds.v(:carat)
```

```{ruby}
diamonds1 = diamonds.rename(carat: 'carat-value')
# diamonds1.carat-value
diamonds1['carat-value']
# diamonds1.v('carat-value')
```

```{ruby}
#| scrolled: true
diamonds1.slice { v('carat-value') > 1 }
# diamonds1.slice { self['carat-value'] > 1 }
```

#### 行 (records, observations) を選択する

| 機能                                     | RedAmber 	               | Tidyverse (R)               | pandas                   | DataFrames.jl |
|---                                       |---                        |---                          |---                       |---            |
| 論理値に従って行を選択して dataframe で返す | **slice**, filter, remove, [] | dplyr::filter               | [], filter, query, loc[] | filter        |
| インデックスで行を選択して dataframe で返す | **slice**, remove, []         | dplyr::slice 	            | iloc[], drop             | subset        |
| 行の順番を入れ替えた dataframeを返す       | **slice**, [] 	             | dplyr::filter, dplyr::slice | reindex, loc[], iloc[]   | permute       |

#### 列を更新する / 新しい列を作る

|機能 	                       | RedAmber 	          | Tidyverse (R)                                     | pandas            | DataFrames.jl |
|---                           |---                  |---                                                 |---                |---            |
| 既存の列の内容を変更する       | **assign** 	            | dplyr::mutate                                    	| assign, []=       | mapcols       |
| 新しい列を作成する 	        | **assign**, assign_left |	dplyr::mutate 	                                    | apply             | insertcols,.+ |
| 新しい列を作成し、残りは捨てる | new 	               | transmute 	                                         | (dfply:)transmute | transform,insertcols,mapcols |
| 列の名前を変更する            | **rename**              |	dplyr::rename, dplyr::rename_with, purrr::set_names | rename, set_axis  | rename        |
| dataframe をソートする        | sort 	              | dplyr::arrange 	                                    | sort_values       | sort          |

```{ruby}
#| collapsed: true
#| jupyter: {outputs_hidden: true, source_hidden: true}
diamonds
  .pick(:depth, :z)
  .assign(:depth, :'diff(depth-z)') do
    depth_mm = depth / 25.4
    diff = depth_mm - z
    [depth_mm, diff]
  end
```

※ (RedAmberで工夫したことその2) **Rubyのブロックと親和性が高い、整理されたメソッド群を作った**

### よくハマってしまうミス

ブロックを `instance_eval` を使ってレシーバのコンテキストでコンテキストで呼んでいるためにおこること

- 列名とメソッド名が同じ
- 列名とローカル変数が同じ

どちらも予期しないメソッドが呼ばれて、ミスに気づきにくい

```{ruby}
diamonds
# diamonds.table
```

```{ruby}
diamonds.x
diamonds.slice { x > 5 }
```

```{ruby}
x = 0
diamonds.slice { x > 5 }
```

Ruby は LISP-2 だから変数名とメソッド名は別の空間に存在できるけれども、適切に管理するべき。

## データフレームの横持ちと縦持ち

メーカー別、年別の輸入車台数データ。日本輸入車組合（ https://www.jaia-jp.org/ja/stats/ ）より。

```{ruby}
# csvからロードする
import_cars = RedAmber::DataFrame.load(Arrow::Buffer.new(<<~CSV), format: :csv)
  Year,Audi,BMW,BMW_MINI,Mercedes-Benz,VW
  2017,28336,52527,25427,68221,49040
  2018,26473,50982,25984,67554,51961
  2019,24222,46814,23813,66553,46794
  2020,22304,35712,20196,57041,36576
  2021,22535,35905,18211,51722,35215
CSV
```

このデータフレームは「Messy」なデータと呼ばれ、データ分析や可視化に適していないとされています。

日本語では、表が横に長いことから「横持ち」のデータと呼ばれます。

このデータをデータ分析や可視化に適した「Tidy　（縦持ち）」なデータフレームにするためには、`#to_long`を使います。

（Tidy, Messyは　Rにおけるデータ処理の神様である　Hadely Wickham の用語です)

```{ruby}
import_cars.to_long

# (:Year, name: :Manufactures, value: :n_of_imported)
```

縦持ちのデータを横持ちに戻すには`#to_wide`を使う。

```{ruby}
df_wide = df_long.to_wide

# (name: :Year, value: :n_of_imported)
```

```{ruby}
df_wide.transpose
```

![データフレームの変形(reshape)](https://raw.githubusercontent.com/heronshoes/red_amber/main/doc/image/reshaping_dataframe.png)

### dataframe を変形するメソッドの比較

| 機能 	                                | RedAmber  | Tidyverse (R)       | pandas      | DataFrames.jl |
|---                                   |---        |---                  |---           |---            |
| 列を行に積む (long dataframe にする)   | to_long   | tidyr::pivot_longer | melt         | stack         |
| 行を列に集める (wide dataframe にする) | to_wide   | tidyr::pivot_wider  | pivot        | unstack       |
| wide dataframe を転置する             | transpose | transpose, t 	      | transpose, T | permutedims   |

※ (RedAmberで工夫したことその3) **良い感じに操作できるデータフレームの変形操作**

## Groupの取扱い

グループはデータフレームでよく登場する重要な概念。例えば売り上げのデータがあったとして、

- 店舗毎の売り上げ合計を求める
- 月毎に売り上げ合計上位３位にある商品を求める

などのタスクの「毎」を取り扱うのがグループ！

```{ruby}
sales = RedAmber::DataFrame.new(
  month: [7, 7, 7, 8, 8, 8],
  store: %w[Tokyo Osaka Osaka Tokyo Osaka Nagoya],
  amount: [158, 81, 95, 120, 90, 278]
)
```

```{ruby}
sales.group(:store)
```

```{ruby}
sales
  .group(:store)
  .sum(:amount)
```

```{ruby}
sales
  .group(:store)
  .summarize { [sum(:amount), count] }
```

```{ruby}
sales
  .group(:store)
  .summarize { [sum(:amount), count] }
```

```{ruby}
subframes = sales.sub_by_value(:store)
```

```{ruby}
subframes.aggregate do
  {
    store: store.one,
    sum_amount: amount.sum,
    count: store.count,
  }
end
```


